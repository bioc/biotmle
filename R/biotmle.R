utils::globalVariables(c("assay<-"))

#' Biomarker Evaluation with Targeted Minimum Loss Estimation of the ATE
#'
#' Computes the causal target parameter defined as the difference between the
#' biomarker expression values under treatment and those same values under no
#' treatment, using Targeted Minimum Loss Estimation.
#'
#' @param se A \code{SummarizedExperiment} containing microarray expression
#'  or next-generation sequencing data in the \code{assays} slot and a matrix of
#'  phenotype-level data in the \code{colData} slot.
#' @param varInt A \code{numeric} indicating the column of the design matrix
#'  corresponding to the treatment or outcome of interest (in the
#'  \code{colData} slot of the \code{SummarizedExperiment} argument "se").
#' @param normalized (logical) - whether the data included in the \code{assay}
#'  slot of the input \code{SummarizedExperiment} object has been normalized
#'  already. The default is set to \code{TRUE} with the expectation that a
#'  normalization method has been applied, appropriate to the type of assay
#'  being analyzed. If set to \code{FALSE}, median normalization is performed
#'  for microarray (i.e., non-RNA-seq) data.
#' @param ngscounts (logical) - whether the data are counts generated from a
#'  next-generation sequencing (NGS) experiment (e.g., RNA-seq). The default
#'  setting assumes continuous expression measures as generated by platforms
#'  that are microarray-type (i.e., so-called "targeted" assays).
#' @param parallel (logical) - whether or not to use parallelization in the
#'  estimation procedure. Invoking parallelization happens through a
#'  combination of calls to \pkg{future} and \pkg{BiocParallel}. If this
#'  argument is set to \code{TRUE}, \code{\link[future]{multiprocess}} is used,
#'  and if \code{FALSE}, \code{\link[future]{sequential}} is used, alongside
#'  \code{\link[BiocParallel]{bplapply}}. Other options for evaluation through
#'  futures may be invoked by setting the argument \code{future_param}.
#' @param bppar_type (character) - specifies the type of backend to be used with
#'  the parallelization invoked by \code{BiocParallel}. Consult the manual page
#'  for \code{\link[BiocParallel]{BiocParallelParam}} for possible types and
#'  descriptions on their appropriate uses. The default for this argument is
#'  \code{NULL}, which silently uses \code{\link[BiocParallel]{DoparParam}}.
#' @param future_param (character) - specifies the type of parallelization to be
#'  invoked when using futures for evaluation. For a list of the available
#'  types, please consult the documentation for \code{\link[future]{plan}}. The
#'  default setting (this argument set to \code{NULL}) silently invokes
#'  \code{\link[future]{multiprocess}}. Be careful if changing this setting.
#' @param cv_folds A \code{numeric} scalar indicating how many folds to use in
#'  performing targeted minimum loss estimation. Cross-validated estimates are
#'  more robust, allowing relaxing of theoretical conditions and construction of
#'  conservative variance estimates.
#' @param g_lib (char vector) - library of learning algorithms to be used in
#'  fitting the propensity score E[A | W] = P(A = a | W).
#' @param Q_lib (char vector) - library of learning algorithms to be used in
#'  fitting the outcome regression E[Y | A, W].
#' @param ... Additional arguments to be passed to \code{\link[tmle]{tmle}} in
#'  fitting the targeted minimum loss estimator of the average treatment effect.
#'
#' @importFrom SummarizedExperiment assay colData rowData SummarizedExperiment
#' @importFrom BiocParallel register bplapply bpprogressbar DoparParam
#' @importFrom future plan multiprocess sequential
#' @importFrom doFuture registerDoFuture
#' @importFrom tibble as_tibble
#'
#' @return S4 object of class \code{biotmle}, generated by sub-classing
#'  \code{SummarizedExperiment}, with additional slots containing \code{tmleOut}
#'  and \code{call}, among others, containing TMLE-based estimates of the
#'  relationship between a biomarker and exposure or outcome variable and the
#'  original call to this function (for user reference), respectively.
#'
#' @export biomarkertmle
#'
#' @examples
#' library(dplyr)
#' library(biotmleData)
#' data(illuminaData)
#' library(SummarizedExperiment)
#'
#' colData(illuminaData) <- colData(illuminaData) %>%
#'   data.frame() %>%
#'   dplyr::mutate(age = as.numeric(age > median(age))) %>%
#'   DataFrame()
#'
#' varInt_index <- which(names(colData(illuminaData)) %in% "benzene")
#'
#' biomarkerTMLEout <- biomarkertmle(
#'   se = illuminaData[1:2, ],
#'   varInt = varInt_index,
#'   parallel = FALSE,
#'   g_lib = c("SL.mean", "SL.glm"),
#'   Q_lib = "SL.glm"
#' )
biomarkertmle <- function(se,
                          varInt,
                          normalized = TRUE,
                          ngscounts = FALSE,
                          parallel = TRUE,
                          bppar_type = NULL,
                          future_param = NULL,
                          cv_folds = 5,
                          g_lib = c(
                            "SL.mean", "SL.glm", "SL.glmnet", "SL.earth"
                          ),
                          Q_lib = c(
                            "SL.mean", "SL.glm", "SL.randomForest"
                          ),
                          ...) {

  # ===========================================================================
  # catch input and return in output object for user convenience
  # ===========================================================================
  call <- match.call(expand.dots = TRUE)

  # ===========================================================================
  # invoke S4 class constructor for "bioTMLE" object
  # ===========================================================================
  biotmle <- .biotmle(
    SummarizedExperiment(
      assays = list(expMeasures = assay(se)),
      rowData = rowData(se),
      colData = colData(se)
    ),
    call = call,
    tmleOut = tibble::as_tibble(matrix(NA, 10, 10)),
    topTable = tibble::as_tibble(matrix(NA, 10, 10))
  )

  # ===========================================================================
  # invoke the voom transform from LIMMA if next-generation sequencing data)
  # ===========================================================================
  if (ngscounts) {
    voom_out <- rnaseq_ic(biotmle)
    voom_exp <- 2^(voom_out$E)
    assay(se) <- voom_exp
  }

  # ===========================================================================
  # set up parallelization based on input
  # ===========================================================================
  doFuture::registerDoFuture()
  if (parallel == TRUE) {
    if (!is.null(future_param)) {
      set_future_param <- parse(text = paste0("future", "::", future_param))
      future::plan(eval(set_future_param))
    } else {
      future::plan(future::multiprocess)
    }
  } else if (parallel == FALSE) {
    warning(paste(
      "Sequential evaluation over many probes may take a long time."
    ))
    future::plan(future::sequential)
  }
  if (!is.null(bppar_type)) {
    bp_type <- eval(parse(text = paste0(
      "BiocParallel", "::",
      bppar_type, "()"
    )))
  } else {
    bp_type <- BiocParallel::DoparParam()
  }
  BiocParallel::bpprogressbar(bp_type) <- TRUE
  BiocParallel::register(bp_type, default = TRUE)

  # ===========================================================================
  # TMLE procedure to identify biomarkers based on an EXPOSURE
  # ===========================================================================
  if (!ngscounts && !normalized) {
    # median normalization
    exp_normed <- limma::normalizeBetweenArrays(as.matrix(assay(se)),
                                                method = "scale")
    Y <- tibble::as_tibble(t(exp_normed))
  } else {
    Y <- tibble::as_tibble(t(as.matrix(assay(se))))
  }
  # simple sanity check of whether Y includes array values
  if (!all(apply(Y, 2, class) == "numeric")) {
    stop("Warning - values in Y do not appear to be numeric.")
  }

  # exposure / treatment
  A <- as.numeric(colData(se)[, varInt])

  # baseline covariates
  W <- tibble::as_tibble(as.data.frame(colData(se)[, -varInt]))
  if (dim(W)[2] == 0) {
    W <- as.numeric(rep(1, length(A)))
  }

  # coerce matrix of baseline covariates to numeric
  if (!all(apply(W, 2, class) == "numeric")) {
    W <- tibble::as_tibble(apply(W, 2, as.numeric))
  }

  # perform multi-level TMLE (of the ATE) for genes as Y
  biomarkerTMLEout <- BiocParallel::bplapply(Y[, seq_along(Y)],
    biomarkerTMLE_exposure,
    W = W,
    A = A,
    g_lib = g_lib,
    Q_lib = Q_lib,
    cv_folds = cv_folds,
    ...
  )
  biomarkerTMLEout <- do.call(cbind.data.frame, biomarkerTMLEout)

  if (!ngscounts) {
    biotmle@tmleOut <- tibble::as_tibble(t(as.matrix(biomarkerTMLEout)))
  } else {
    voom_out$E <- t(as.matrix(biomarkerTMLEout))
    biotmle@tmleOut <- voom_out
  }
  return(biotmle)
}

################################################################################

#' TMLE procedure using ATE for Biomarker Identication from Exposure
#'
#' This function performs influence curve-based estimation of the effect of an
#' exposure on biological expression values associated with a given biomarker,
#' controlling for a user-specified set of baseline covariates.
#'
#' @param Y A \code{numeric} vector of expression values for a single biomarker.
#' @param W A \code{Matrix} of \code{numeric} values corresponding to baseline
#'  covariates to be marginalized over in the estimation process.
#' @param A A \code{numeric} vector of discretized exposure vector (e.g., from a
#'  design matrix whose effect on expression values is of interest.
#' @param g_lib A \code{character} vector identifying the library of learning
#'  algorithms to be used in fitting the propensity score P[A = a | W].
#' @param Q_lib A \code{character} vector identifying the library of learning
#'  algorithms to be used in fitting the outcome regression E[Y | A, W].
#' @param cv_folds A \code{numeric} scalar indicating how many folds to use in
#'  performing targeted minimum loss estimation. Cross-validated estimates are
#'  more robust, allowing relaxing of theoretical conditions and construction of
#'  conservative variance estimates.
#' @param ... Additional arguments passed to \code{\link[drtmle]{drtmle}} in
#'  fitting the targeted minimum loss estimator of the average treatment effect.
#'
#' @importFrom assertthat assert_that
#' @importFrom drtmle drtmle
#'
#' @return TMLE-based estimate of the relationship between biomarker expression
#'  and changes in an exposure variable, computed iteratively and saved in the
#'  \code{tmleOut} slot in a \code{biotmle} object.
#
biomarkerTMLE_exposure <- function(Y,
                                   W,
                                   A,
                                   g_lib,
                                   Q_lib,
                                   cv_folds,
                                   ...) {
  # check the case that Y is passed in as a column of a data.frame
  if (any(class(Y) == "data.frame")) Y <- as.numeric(unlist(Y[, 1]))
  if (any(class(A) == "data.frame")) A <- as.numeric(unlist(A[, 1]))
  assertthat::assert_that(length(unique(A)) > 1)

  # fit standard (possibly CV) TML estimator (n.b., guard = NULL)
  a_0 <- sort(unique(A[!is.na(A)]))
  tmle_fit <- drtmle::drtmle(Y = Y,
                             A = A,
                             W = W,
                             a_0 = a_0,
                             stratify = TRUE,
                             SL_g = g_lib,
                             SL_Q = Q_lib,
                             cvFolds = cv_folds,
                             returnModels = TRUE,
                             guard = NULL,
                             parallel = FALSE,
                             use_future = FALSE,
                             ...)

  # compute ATE and estimated EIF by delta method
  ate_tmle <- tmle_fit$tmle$est[seq_along(a_0)[-1]] - tmle_fit$tmle$est[1]
  eif_tmle_delta <- tmle_fit$ic$ic[, seq_along(a_0)[-1]] - tmle_fit$ic$ic[, 1]

  # return only highest contrast (e.g., a[1] v a[5]) if many contrasts
  if (!is.vector(eif_tmle_delta)) {
    out <- eif_tmle_delta[, ncol(eif_tmle_delta)] + ate_tmle[length(ate_tmle)]
  } else {
    out <- eif_tmle_delta + ate_tmle
  }
  assertthat::assert_that(is.vector(out))
  return(out)
}
